================================================================================
                    COMPREHENSIVE ML MODELS TRAINING SUMMARY
                    Sensor Calibration Platform - Machine Learning Analysis
================================================================================

OVERVIEW
--------
This document provides a complete technical analysis of all Machine Learning models 
implemented in the Sensor Calibration Platform. The system employs three distinct 
types of ML models for comprehensive sensor data analysis and management.

================================================================================
1. ANOMALY DETECTION MODELS
================================================================================

PURPOSE:
--------
Anomaly detection models identify unusual patterns, spikes, drops, noise, and 
calibration errors in sensor readings to ensure data quality and system reliability.

ALGORITHM USED:
---------------
- Primary Algorithm: Isolation Forest (from sklearn.ensemble.IsolationForest)
- Contamination Rate: 0.1 (10% of data expected to be anomalies)
- Random State: 42 (for reproducibility)
- Number of Estimators: 100 trees
- Decision Function: Returns anomaly scores for confidence measurement

TRAINING PROCESS:
-----------------
Location: sensors/services/model_training.py -> train_anomaly_detection_model()

1. DATA COLLECTION:
   - Minimum Required: 10 sensor readings
   - Data Source: Reading.objects.filter(sensor_id=sensor_id).order_by('timestamp')
   - Raw Values: np.array([r.raw_value for r in readings]).reshape(-1, 1)

2. FEATURE ENGINEERING:
   - Primary Feature: Raw sensor values
   - Time Features: Hour of day (0-23), Day of week (0-6)
   - Combined Features: np.hstack([values, time_features])
   - Feature Vector: [raw_value, hour, day_of_week]

3. MODEL TRAINING:
   - Algorithm: IsolationForest(contamination=0.1, random_state=42, n_estimators=100)
   - Training: model.fit(X) where X contains value and time features
   - Output: Binary classification (-1 = anomaly, 1 = normal)

4. MODEL PERSISTENCE:
   - File Format: .joblib (using joblib.dump())
   - Naming Convention: anomaly_model_{sensor_name}_{sensor_id}.joblib
   - Storage Location: trained_models/ directory

5. EVALUATION:
   - Test on training data: model.predict(X)
   - Count anomalies: np.sum(predictions == -1)
   - Return training statistics and detected anomaly count

ANOMALY CLASSIFICATION LOGIC:
-----------------------------
Location: sensors/services/anomaly_ml.py -> ml_anomaly_detection()

Anomaly types are classified based on deviation patterns:
- Spike: |deviation| > 50%
- Dropout: raw_value < expected * 0.3
- Noise: 20% < |deviation| < 50%
- Calibration Error: 10% < |deviation| < 20%
- Drift: Default classification for other anomalies

Severity Levels:
- High: |deviation| > 15%
- Medium: |deviation| <= 15%

PREDICTION PROCESS:
-------------------
Location: sensors/services/enhanced_ml_services.py -> predict_anomaly_with_trained_model()

1. Model Loading: joblib.load(model_path)
2. Feature Preparation: [reading_value, timestamp.hour, timestamp.weekday()]
3. Prediction: model.predict(features)[0]
4. Confidence: abs(model.decision_function(features)[0])
5. Fallback: Basic threshold detection if model unavailable

CURRENT TRAINED MODELS:
-----------------------
- anomaly_model_Compressor Pressure Sensor_18.joblib
- anomaly_model_Conveyor Vibration Sensor_15.joblib
- anomaly_model_Cooling Tank Pressure_13.joblib
- anomaly_model_Humidity Chamber Sensor_14.joblib
- anomaly_model_Motor Vibration Sensor_20.joblib
- anomaly_model_Reactor Temp Sensor_17.joblib
- anomaly_model_Warehouse Humidity Sensor_19.joblib

================================================================================
2. DRIFT PREDICTION MODELS
================================================================================

PURPOSE:
--------
Drift prediction models forecast future sensor drift patterns to enable 
proactive maintenance and calibration scheduling before sensors become unreliable.

ALGORITHM USED:
---------------
- Primary Algorithm: Linear Regression (from sklearn.linear_model.LinearRegression)
- Feature Engineering: Rolling statistics, time-based features
- Target Variable: Drift percentage from baseline

TRAINING PROCESS:
-----------------
Location: sensors/services/model_training.py -> train_drift_prediction_model()

1. DATA COLLECTION:
   - Minimum Required: 20 sensor readings
   - Data Source: Reading.objects.filter(sensor=sensor).order_by('timestamp')
   - Time Series: Values and timestamps from historical readings

2. BASELINE CALCULATION:
   - Baseline: sensor.value or np.mean(values[:5]) (first 5 readings)
   - Drift Calculation: ((values - baseline) / baseline * 100)

3. FEATURE ENGINEERING:
   - Rolling Mean: pd.Series(values).rolling(window=window_size).mean()
   - Rolling Standard Deviation: pd.Series(values).rolling(window=window_size).std()
   - Time Since Start: (timestamp - first_timestamp).total_seconds() / 3600 (hours)
   - Previous Value: values[:-1]
   - Feature Matrix: [previous_value, rolling_mean, rolling_std, time_since_start]

4. TARGET VARIABLE:
   - Next Drift Value: drift_values[1:]
   - Training Pairs: (X[i], y[i]) where y[i] is next drift value

5. MODEL TRAINING:
   - Algorithm: LinearRegression()
   - Training: model.fit(X, y)
   - Evaluation: mean_squared_error(y, model.predict(X))

6. MODEL PERSISTENCE:
   - File Format: .joblib
   - Naming Convention: drift_model_{sensor_name}_{sensor_id}.joblib

PREDICTION PROCESS:
-------------------
Location: sensors/services/enhanced_ml_services.py -> predict_drift_with_trained_model()

1. Model Loading: joblib.load(model_path)
2. Recent Data: Last 10 readings for feature calculation
3. Feature Preparation:
   - Current value, rolling mean, rolling std, time since start
4. Iterative Prediction:
   - Predict next drift value
   - Update features for next prediction
   - Repeat for future_points (default: 5)
5. Fallback: Simple linear trend if model unavailable

CURRENT TRAINED MODELS:
-----------------------
- drift_model_Compressor Pressure Sensor_18.joblib
- drift_model_Conveyor Vibration Sensor_15.joblib
- drift_model_Cooling Tank Pressure_13.joblib
- drift_model_Humidity Chamber Sensor_14.joblib
- drift_model_Motor Vibration Sensor_20.joblib
- drift_model_Reactor Temp Sensor_17.joblib
- drift_model_Warehouse Humidity Sensor_19.joblib

================================================================================
3. CALIBRATION MODELS
================================================================================

PURPOSE:
--------
Calibration models learn from historical calibration data to automatically 
correct sensor readings, reducing manual calibration frequency and improving 
measurement accuracy.

ALGORITHM USED:
---------------
- Primary Algorithm: Linear Regression (from sklearn.linear_model.LinearRegression)
- Training Data: Historical calibration records with raw and corrected values
- Purpose: Learn correction patterns from past calibrations

TRAINING PROCESS:
-----------------
Location: sensors/services/model_training.py -> train_calibration_model()

1. DATA COLLECTION:
   - Minimum Required: 5 calibration records
   - Data Source: Calibration.objects.filter(sensor=sensor).order_by('applied_at')
   - Additional Data: Readings before each calibration

2. CALIBRATION DATA PREPARATION:
   - For each calibration:
     - Get 3 readings before calibration timestamp
     - Calculate average raw value from readings
     - Store: {raw_value, corrected_value, method, timestamp}

3. FEATURE ENGINEERING:
   - Input Features: Raw sensor values (X = np.array([[raw_value]]))
   - Target Variable: Corrected values (y = np.array([corrected_value]))
   - Training Pairs: (raw_value, corrected_value)

4. MODEL TRAINING:
   - Algorithm: LinearRegression()
   - Training: model.fit(X, y)
   - Evaluation: mean_squared_error(y, model.predict(X))

5. MODEL PERSISTENCE:
   - File Format: .joblib
   - Naming Convention: calibration_model_{sensor_name}_{sensor_id}.joblib

PREDICTION PROCESS:
-------------------
Location: sensors/services/enhanced_ml_services.py -> apply_adaptive_calibration_with_trained_model()

1. Model Loading: joblib.load(model_path)
2. Input: Raw sensor reading value
3. Prediction: model.predict(np.array([[raw_value]]))[0]
4. Output: Corrected value and correction factor
5. Fallback: Basic linear correction if model unavailable

CURRENT TRAINED MODELS:
-----------------------
- calibration_model_Cooling Tank Pressure_13.joblib

================================================================================
4. MODEL MANAGEMENT AND AUTOMATION
================================================================================

AUTOMATIC TRAINING SYSTEM:
--------------------------
Location: sensors/services/ml_analytics.py -> auto_train_models_if_needed()

TRIGGER CONDITIONS:
- Models older than 7 days
- Missing model files
- Minimum data requirements met:
  * Anomaly: 20+ readings
  * Drift: 20+ readings  
  * Calibration: 5+ calibration records

TRAINING SCHEDULE:
- Automatic: Every hour (configurable interval)
- Manual: Via Django management commands
- API: Through ModelTrainingAPIView

MANAGEMENT COMMANDS:
-------------------
1. train_models.py:
   - Train specific model types for specific sensors
   - Train all models for all sensors
   - Command: python manage.py train_models --sensor-id X --model-type Y

2. auto_train_models.py:
   - Background automatic training service
   - Configurable intervals (default: 3600 seconds)
   - Command: python manage.py auto_train_models --interval 3600

MODEL PERSISTENCE AND STORAGE:
------------------------------
- Storage Directory: trained_models/
- File Format: .joblib (scikit-learn serialization)
- Model Metadata: Creation time, file size, sensor information
- Model Info API: GET /api/models/ returns model information

================================================================================
5. ENHANCED ML SERVICES INTEGRATION
================================================================================

SERVICE ARCHITECTURE:
---------------------
Location: sensors/services/enhanced_ml_services.py

CLASS: EnhancedMLServices
- Integrates all three model types
- Provides fallback mechanisms
- Handles model loading and prediction
- Manages automatic retraining

KEY METHODS:
1. predict_anomaly_with_trained_model(sensor_id, reading_value, timestamp)
2. predict_drift_with_trained_model(sensor_id, future_points=5)
3. apply_adaptive_calibration_with_trained_model(sensor_id, raw_value)
4. auto_train_models_if_needed(sensor_id)

FALLBACK MECHANISMS:
-------------------
- Anomaly Detection: Basic threshold-based detection
- Drift Prediction: Simple linear trend analysis
- Calibration: Basic linear correction (10% adjustment)

================================================================================
6. API INTEGRATION
================================================================================

ENDPOINTS:
----------
Location: sensors/views.py

1. ModelTrainingAPIView:
   - POST /api/train-models/ - Train models
   - GET /api/train-models/ - Get model information

2. EnhancedAnomalyDetectionAPIView:
   - POST /api/enhanced-anomaly-detection/ - Use trained models for prediction

REQUEST FORMATS:
----------------
Training Request:
{
    "sensor_id": 1,
    "model_type": "anomaly|drift|calibration|all"
}

Prediction Request:
{
    "sensor_id": 1,
    "reading_value": 25.5,
    "timestamp": "2024-01-01T12:00:00Z"
}

================================================================================
7. PERFORMANCE METRICS AND ANALYTICS
================================================================================

ANALYTICS SERVICE:
-----------------
Location: sensors/services/ml_analytics.py -> MLAnalyticsService

METRICS CALCULATED:
1. Anomaly Detection Rate: Based on severity distribution of recent anomalies
2. Drift Prediction Accuracy: Based on reading consistency and drift patterns
3. Calibration Improvement: Based on calibration frequency and adaptive methods
4. Model Statistics: Total models, active models, model ages

PERFORMANCE INDICATORS:
- Active Models: Models less than 7 days old
- Detection Rate: 85-100% based on critical anomaly detection
- Drift Accuracy: 85-98% based on sensor consistency
- Calibration Improvement: 80-95% based on adaptive method usage

================================================================================
8. TECHNICAL IMPLEMENTATION DETAILS
================================================================================

DEPENDENCIES:
-------------
- numpy: Numerical computations and array operations
- pandas: Time series data manipulation and rolling statistics
- scikit-learn: Machine learning algorithms (IsolationForest, LinearRegression)
- joblib: Model serialization and persistence
- Django ORM: Database operations and data retrieval

DATA FLOW:
----------
1. Sensor Readings → Database (Reading model)
2. Calibration Records → Database (Calibration model)
3. Training Data → Feature Engineering → Model Training
4. Trained Models → Persistence (.joblib files)
5. New Readings → Model Loading → Prediction → Results

ERROR HANDLING:
--------------
- Insufficient data: Minimum reading requirements enforced
- Model loading failures: Fallback to basic algorithms
- Training failures: Error logging and graceful degradation
- API errors: Proper HTTP status codes and error messages

================================================================================
9. MODEL TRAINING ALGORITHMS SUMMARY
================================================================================

ANOMALY DETECTION:
- Algorithm: Isolation Forest
- Features: [raw_value, hour, day_of_week]
- Output: Binary classification (-1/1) + confidence score
- Contamination: 10% expected anomalies
- Trees: 100 estimators

DRIFT PREDICTION:
- Algorithm: Linear Regression
- Features: [previous_value, rolling_mean, rolling_std, time_since_start]
- Output: Drift percentage prediction
- Target: Next drift value in time series
- Evaluation: Mean Squared Error

CALIBRATION:
- Algorithm: Linear Regression
- Features: [raw_value]
- Output: Corrected value
- Target: Historical corrected values
- Training: Raw → Corrected value mapping

================================================================================
10. CURRENT MODEL INVENTORY
================================================================================

TOTAL MODELS: 15 trained models across 7 sensors

ANOMALY MODELS: 7 models
- Compressor Pressure Sensor (ID: 18)
- Conveyor Vibration Sensor (ID: 15)
- Cooling Tank Pressure (ID: 13)
- Humidity Chamber Sensor (ID: 14)
- Motor Vibration Sensor (ID: 20)
- Reactor Temp Sensor (ID: 17)
- Warehouse Humidity Sensor (ID: 19)

DRIFT MODELS: 7 models
- Same sensors as anomaly models
- All trained with time series drift prediction

CALIBRATION MODELS: 1 model
- Cooling Tank Pressure (ID: 13)
- Only sensor with sufficient calibration history (5+ records)

================================================================================
CONCLUSION
================================================================================

The Sensor Calibration Platform implements a comprehensive Machine Learning 
ecosystem with three specialized model types working in concert to provide:

1. Real-time anomaly detection for data quality assurance
2. Predictive drift analysis for proactive maintenance
3. Adaptive calibration for automated sensor correction

The system features robust training pipelines, automatic model management, 
fallback mechanisms, and comprehensive analytics. All models are trained 
using industry-standard algorithms with proper feature engineering and 
evaluation metrics.

The ML infrastructure supports both manual and automatic training workflows, 
with models automatically retrained when they become outdated or when 
sufficient new data becomes available.

================================================================================
END OF SUMMARY
================================================================================
